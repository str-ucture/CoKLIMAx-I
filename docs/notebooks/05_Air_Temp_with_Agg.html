

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2D Air Temperature Aggregation Tool &mdash; CoKLIMAx 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=822aaed9" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script type="application/vnd.jupyter.widget-state+json">{"state": {"245fa01f1128463b8a207ccd5aae0f23": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "2330d9a58b8644b1893e0734f31bbba0": {"model_name": "DescriptionStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "StyleView", "description_width": ""}}, "b3a5fcd87d0a409e95b16f6d3fb2e4d3": {"model_name": "DropdownModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "DropdownModel", "_options_labels": ["ta_2m*_xy", "tsurf*_xy", "wspeed_10m*_xy", "bio_pet*_xy", "bio_utci*_xy"], "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "DropdownView", "description": "Select test variable:", "description_allow_html": false, "disabled": false, "index": 0, "layout": "IPY_MODEL_245fa01f1128463b8a207ccd5aae0f23", "style": "IPY_MODEL_2330d9a58b8644b1893e0734f31bbba0", "tabbable": null, "tooltip": null}}}, "version_major": 2, "version_minor": 0}</script>
      <script crossorigin="anonymous" data-jupyter-widgets-cdn="https://cdn.jsdelivr.net/npm/" src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@1.0.6/dist/embed-amd.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="2D Biometeorological Variable Analysis: Baseline vs. Scenario" href="06_Bio_Var_Analysis_BS_vs_S1.html" />
    <link rel="prev" title="2D Air Temperature Analysis: Heatmaps" href="04_Air_Temp_Analysis_Heatmaps.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            CoKLIMAx
              <img src="../_static/coklimax_logo_new.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Data Preparation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="_01_2D_Var_Agg_and_Extract.html">2D Variable Aggregation and Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="_02_3D_to_2d_Surface_Var_Extract.html">3D Variable Surface Extraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="_03_2D_Surface_Var_Agg_and_Extract.html">3D Variable Extraction and Aggregation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Preminimary:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="01_Obs_vs_Sim.html">Comparison of Observed vs Simulation Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_Distance_of_AOI_vs_t-test.html">Distance of AOI vs t-test</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variable: Temperature:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="03_Air_Temp_Analysis_BS_vs_S1.html">2D Air Temperature Analysis: Baseline vs. Scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_Air_Temp_Analysis_Heatmaps.html">2D Air Temperature Analysis: Heatmaps</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2D Air Temperature Aggregation Tool</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#import-dependencies">1. Import dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="#load-simulation-data">2. Load Simulation Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#variable-selection">3. Variable Selection</a></li>
<li class="toctree-l2"><a class="reference internal" href="#define-time-sequences-and-aggregation-logic">4. Define Time Sequences and Aggregation Logic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prepare-data-for-aggregation">5. Prepare Data for Aggregation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#perform-aggregation-and-save-data">6. Perform Aggregation and Save Data</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Variables: Biometeorology:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="06_Bio_Var_Analysis_BS_vs_S1.html">2D Biometeorological Variable Analysis: Baseline vs. Scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Bio_Var_Analysis_BS_vs_S1.html">Biological Variable Analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CoKLIMAx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">2D Air Temperature Aggregation Tool</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/notebooks/05_Air_Temp_with_Agg.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="d-air-temperature-aggregation-tool">
<h1>2D Air Temperature Aggregation Tool<a class="headerlink" href="#d-air-temperature-aggregation-tool" title="Link to this heading"></a></h1>
<p>This notebook provides a robust tool for extracting 2-meter air temperature (<code class="docutils literal notranslate"><span class="pre">ta_2m</span></code>) data from PALM (Potsdam Atmospheric Large-Eddy Simulation Model) 2D NetCDF output files and performing temporal aggregation. The primary goal is to generate aggregated <code class="docutils literal notranslate"><span class="pre">ta_2m</span></code> NetCDF files (e.g., hourly averages) from potentially finer-resolution simulation outputs. These aggregated files can then be used as input for subsequent analysis notebooks, streamlining data workflows.</p>
<section id="import-dependencies">
<h2>1. Import dependencies<a class="headerlink" href="#import-dependencies" title="Link to this heading"></a></h2>
<p>This section imports all necessary Python libraries for numerical operations, NetCDF file handling, interactive widget creation for user input, and basic operating system interactions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">netCDF4</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">netCDF4</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dataset</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ipywidgets</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">widgets</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">palm_variables</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="load-simulation-data">
<h2>2. Load Simulation Data<a class="headerlink" href="#load-simulation-data" title="Link to this heading"></a></h2>
<p>This section defines the file paths for the 2D simulation output NetCDF files (for a baseline and a scenario run) and the static driver file. These files are then loaded into netCDF4 Dataset objects, making their contents accessible for processing. The static driver is included for potential future use (e.g., extracting building masks or grid information).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Absolute URLs (paths) of 2D xy-averaged simulation output files.</span>
<span class="n">file_xy_1</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;./Data/_simulation_outputs_3/konstanz_4096x4096_v9_Baseline-48hr/OUTPUT/konstanz_4096x4096_v9_Baseline_av_xy_N03.000.nc&quot;</span>
<span class="n">file_xy_2</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;./Data/_simulation_outputs_3/konstanz_4096x4096_v9_Scenario_1-48hr/OUTPUT/konstanz_4096x4096_v9_Scenario_1_av_xy_N03.000.nc&quot;</span>
<span class="n">file_static</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;./Data/_simulation_outputs_3/konstanz_4096x4096_v9_Scenario_1-48hr/INPUT/konstanz_4096x4096_v9_Scenario_1_static_N03&quot;</span>

<span class="c1"># Read NetCDF files into Dataset objects in read mode (&#39;r&#39;).</span>
<span class="n">dataset_1</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">file_xy_1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">dataset_2</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">file_xy_2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">dataset_3</span> <span class="o">=</span> <span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">file_static</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1"># Loaded for completeness, but not explicitly used later in *this* notebook.</span>

<span class="c1"># Store the Dataset objects and their corresponding file paths in lists for easy iteration.</span>
<span class="n">file_xy_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_xy_1</span><span class="p">,</span> <span class="n">file_xy_2</span><span class="p">]</span>
<span class="n">dataset_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset_1</span><span class="p">,</span> <span class="n">dataset_2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="variable-selection">
<h2>3. Variable Selection<a class="headerlink" href="#variable-selection" title="Link to this heading"></a></h2>
<p>This section allows the user to interactively select a 2D variable from the loaded NetCDF datasets. A dropdown widget is provided for selection, and the chosen variable’s description and unit (retrieved from the palm_variables module) are displayed for clear identification.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract variable names from the first dataset where the number of dimensions is greater than 2.</span>
<span class="c1"># In PALM xy-averaged output files (`_av_xy_N03.000.nc`), these typically represent 2D spatial data over time (time, z_fixed_level, y, x) or (time, y, x).</span>
<span class="n">var_names_palm</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dataset_1</span><span class="o">.</span><span class="n">variables</span> <span class="k">if</span> <span class="n">dataset_1</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">]</span>

<span class="c1"># Initialize `test_variable` with the first variable in the list (`var_names_palm[0]`),</span>
<span class="c1"># which is commonly &#39;ta_2m*_xy&#39; for 2-m air temperature in these types of files.</span>
<span class="n">test_variable</span> <span class="o">=</span> <span class="n">var_names_palm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Create a dropdown widget to allow the user to select the desired 2D variable.</span>
<span class="n">drop_down</span> <span class="o">=</span> <span class="n">widgets</span><span class="o">.</span><span class="n">Dropdown</span><span class="p">(</span>
    <span class="n">options</span><span class="o">=</span><span class="n">var_names_palm</span><span class="p">,</span>         <span class="c1"># Populate the dropdown with the extracted 2D variable names.</span>
    <span class="n">value</span><span class="o">=</span><span class="n">var_names_palm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>        <span class="c1"># Set the initial selected value in the dropdown.</span>
    <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Select test variable:&#39;</span> <span class="c1"># Label displayed next to the dropdown.</span>
<span class="p">)</span>

<span class="c1"># Define a handler function that will be called whenever the dropdown&#39;s value changes.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">dropdown_handler</span><span class="p">(</span><span class="n">change</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">test_variable</span>  <span class="c1"># Declare `test_variable` as global to modify it.</span>
    <span class="n">test_variable</span> <span class="o">=</span> <span class="n">change</span><span class="o">.</span><span class="n">new</span>     <span class="c1"># Update the global `test_variable` with the newly selected value.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selected variable: </span><span class="si">{</span><span class="n">test_variable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="c1"># Print the newly selected variable to the console.</span>

<span class="c1"># Attach the `dropdown_handler` function to observe changes in the &#39;value&#39; property of the dropdown.</span>
<span class="n">drop_down</span><span class="o">.</span><span class="n">observe</span><span class="p">(</span><span class="n">dropdown_handler</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="s1">&#39;value&#39;</span><span class="p">)</span>

<span class="c1"># Display the dropdown widget in the notebook output.</span>
<span class="n">display</span><span class="p">(</span><span class="n">drop_down</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"version_major": 2, "version_minor": 0, "model_id": "b3a5fcd87d0a409e95b16f6d3fb2e4d3"}</script></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check if the selected `test_variable` string contains a wildcard character &#39;*&#39;.</span>
<span class="c1"># This is common for PALM 2D xy-averaged variables (e.g., &#39;ta_2m*_xy&#39;).</span>
<span class="k">if</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">test_variable</span><span class="p">:</span>
    <span class="c1"># If a wildcard is present, extract the base part of the variable name (e.g., &#39;ta_2m&#39; from &#39;ta_2m*_xy&#39;)</span>
    <span class="c1"># and re-append &#39;*&#39; to match the keys in `palm_variables.variables_dict`.</span>
    <span class="n">var_initial</span> <span class="o">=</span> <span class="n">test_variable</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;*&quot;</span>
    <span class="c1"># Retrieve the dictionary of information for `var_initial` from the `palm_variables` module.</span>
    <span class="n">variable_info</span> <span class="o">=</span> <span class="n">palm_variables</span><span class="o">.</span><span class="n">variables_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_initial</span><span class="p">,</span> <span class="p">{})</span>
    <span class="c1"># Extract the &#39;unit&#39; from `variable_info`, defaulting to &#39;No unit available&#39; if the key is missing.</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">variable_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span> <span class="s1">&#39;No unit available&#39;</span><span class="p">)</span>
    <span class="c1"># Extract the &#39;description&#39; from `variable_info`, defaulting to &#39;No description available&#39; if the key is missing.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="n">variable_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;description&#39;</span><span class="p">,</span> <span class="s1">&#39;No description available&#39;</span><span class="p">)</span>
    <span class="c1"># Print the capitalized description and its unit.</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">description</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2-m air temperature, °C
</pre></div>
</div>
</div>
</div>
</section>
<section id="define-time-sequences-and-aggregation-logic">
<h2>4. Define Time Sequences and Aggregation Logic<a class="headerlink" href="#define-time-sequences-and-aggregation-logic" title="Link to this heading"></a></h2>
<p>This section dynamically extracts the total number of time steps from the loaded dataset. It then defines the get_aggregate_time_list function, which creates lists of time step indices for temporal aggregation. This function generates moving windows of time steps, enabling the calculation of aggregated values (e.g., averages) over specified durations.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_aggregate_time_list</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">,</span> <span class="n">aggregate_time_steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list of time step ranges for temporal aggregation, creating a moving window.</span>

<span class="sd">    Args:</span>
<span class="sd">        total_time_steps (int): Total number of time steps in the simulation.</span>
<span class="sd">        aggregate_time_steps (int): The size of the aggregation window (number of time steps).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list where each element is a sub-list of time step indices</span>
<span class="sd">              representing an aggregation window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time_lists</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">aggregate_time_steps</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># No aggregation: window is just the current time step.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">half_window</span> <span class="o">=</span> <span class="n">aggregate_time_steps</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># Calculate half-window size.</span>
            
            <span class="c1"># Determine the start and end indices of the window based on even/odd `aggregate_time_steps`.</span>
            <span class="k">if</span> <span class="n">aggregate_time_steps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># For even window, it&#39;s centered such that `i` is towards the end of the first half.</span>
                <span class="c1"># Example: for aggregate_time_steps=6, half_window=3. For `i=10`, range is [7, 13) -&gt; [7, 8, 9, 10, 11, 12].</span>
                <span class="n">time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_window</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">half_window</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># For odd window, it&#39;s perfectly centered around `i`.</span>
                <span class="c1"># Example: for aggregate_time_steps=5, half_window=2. For `i=10`, range is [8, 13) -&gt; [8, 9, 10, 11, 12].</span>
                <span class="n">time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">half_window</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">half_window</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># Filter out time indices that are outside the total simulation time steps.</span>
        <span class="n">valid_time_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">time_list</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">total_time_steps</span><span class="p">]</span>
        <span class="n">time_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">valid_time_list</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">time_lists</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="prepare-data-for-aggregation">
<h2>5. Prepare Data for Aggregation<a class="headerlink" href="#prepare-data-for-aggregation" title="Link to this heading"></a></h2>
<p>This section prepares the necessary data for the aggregation process. It extracts the base filenames from the input simulation files and loads the selected 2D variable data from both dataset_1 and dataset_2. It also sets the aggregate_time_steps parameter (defaulting to 1, meaning no aggregation is performed by default) and generates the corresponding time_lists for aggregation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract the base filename (without path and extension) from the first xy output file.</span>
<span class="c1"># This will be used in naming the aggregated output files.</span>
<span class="n">filename_xy_1</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_xy_1</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># Extract the base filename for the second xy output file.</span>
<span class="c1"># Corrected from original: ensure `filename_xy_2` comes from `file_xy_2`.</span>
<span class="n">filename_xy_2</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_xy_2</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Load the actual variable data for the selected `test_variable` from both `dataset_1` and `dataset_2`.</span>
<span class="c1"># `test_variable` is determined by the dropdown selection in a previous step.</span>
<span class="n">variable_data_1</span> <span class="o">=</span> <span class="n">dataset_1</span><span class="p">[</span><span class="n">test_variable</span><span class="p">]</span>
<span class="n">variable_data_2</span> <span class="o">=</span> <span class="n">dataset_2</span><span class="p">[</span><span class="n">test_variable</span><span class="p">]</span>

<span class="c1"># Get the full shape of the 2D variable data (time, y, x) from `dataset_1`.</span>
<span class="c1"># The first element (`[0]`) gives the total number of time steps.</span>
<span class="n">variable_data_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataset_1</span><span class="p">[</span><span class="n">test_variable</span><span class="p">])</span>
<span class="n">total_time_steps</span> <span class="o">=</span> <span class="n">variable_data_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Define the aggregation window size.</span>
<span class="c1"># A value of 1 means no aggregation (individual time steps are processed).</span>
<span class="c1"># Change this value (e.g., to 6 for hourly averages) to perform temporal aggregation.</span>
<span class="n">aggregate_time_steps</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># Default to no aggregation.</span>

<span class="c1"># Generate the list of time step ranges for aggregation based on the defined window.</span>
<span class="c1"># This list (`time_lists`) will guide the averaging process.</span>
<span class="n">time_lists</span> <span class="o">=</span> <span class="n">get_aggregate_time_list</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">,</span> <span class="n">aggregate_time_steps</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="perform-aggregation-and-save-data">
<h2>6. Perform Aggregation and Save Data<a class="headerlink" href="#perform-aggregation-and-save-data" title="Link to this heading"></a></h2>
<p>This final section iterates through the loaded simulation datasets. For each dataset, it computes the temporal aggregate of the selected 2D variable using the previously defined aggregation windows (time_lists). The aggregated data is then saved into new NetCDF files, organized in a subdirectory named after the aggregation window size. A check is included to skip the export if the file already exists to prevent accidental overwrites.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Iterate through each dataset in the `dataset_list` (e.g., Baseline and Scenario 1 simulations).</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">current_dataset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dataset_list</span><span class="p">):</span>
    <span class="c1"># Extract the variable data for the `test_variable` from the current dataset.</span>
    <span class="n">variable_data</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="p">[</span><span class="n">test_variable</span><span class="p">]</span>
    
    <span class="c1"># Get the total number of time steps for the current variable data.</span>
    <span class="n">current_total_time_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">variable_data</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Regenerate `time_lists` to ensure it&#39;s correct for the current dataset&#39;s total time steps,</span>
    <span class="c1"># in case datasets have different lengths or `aggregate_time_steps` was changed.</span>
    <span class="n">time_lists</span> <span class="o">=</span> <span class="n">get_aggregate_time_list</span><span class="p">(</span><span class="n">current_total_time_steps</span><span class="p">,</span> <span class="n">aggregate_time_steps</span><span class="p">)</span>
    
    <span class="c1"># Initialize a list to store the aggregated 2D arrays for all time steps.</span>
    <span class="n">variable_data_agg</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Loop through each generated time window (`time_list`) to compute the aggregate.</span>
    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">time_window_indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_lists</span><span class="p">):</span>
        <span class="n">values_in_window</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># For each time index within the current window, extract the 2D slice of the variable.</span>
        <span class="c1"># Assuming `variable_data` has dimensions (time, z_fixed_level, y, x) or (time, y, x).</span>
        <span class="c1"># If it&#39;s 4D (time, z, y, x), `variable_data[time_idx, 0, :, :]` extracts the 2D slice at z=0.</span>
        <span class="c1"># If it&#39;s 3D (time, y, x), `variable_data[time_idx, :, :]` extracts the 2D slice directly.</span>
        <span class="c1"># The following handles both cases assuming `z_fixed_level` is at index 1 if present.</span>
        <span class="k">if</span> <span class="n">variable_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="n">time_window_indices</span><span class="p">:</span>
                <span class="n">values_in_window</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_data</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">elif</span> <span class="n">variable_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">time_idx</span> <span class="ow">in</span> <span class="n">time_window_indices</span><span class="p">:</span>
                <span class="n">values_in_window</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">variable_data</span><span class="p">[</span><span class="n">time_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected number of dimensions for variable </span><span class="si">{</span><span class="n">test_variable</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">variable_data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            
        <span class="c1"># Compute the mean of all 2D slices collected in the current window along the time axis (axis=0).</span>
        <span class="c1"># This results in a single 2D array representing the aggregated value for that time window.</span>
        <span class="n">variable_data_agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values_in_window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        
    <span class="c1"># Determine the base filename for the output NetCDF file from the original file path.</span>
    <span class="n">source_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">file_xy_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Construct the `output_filename` by appending the `test_variable` name (with &#39;*&#39; removed if present).</span>
    <span class="n">output_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">source_filename</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">test_variable</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    
    <span class="c1"># Define the output directory path.</span>
    <span class="n">output_directory</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;./output/04_aggregated_2D_data/&quot;</span> <span class="c1"># Example: ./output/aggregated_2D_data/</span>
    <span class="c1"># Create the output directory if it doesn&#39;t already exist. `exist_ok=True` prevents an error if it exists.</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_directory</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Construct the full output file path.</span>
    <span class="n">output_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_directory</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">output_filename</span><span class="si">}</span><span class="s2">.nc&quot;</span><span class="p">)</span>

    <span class="c1"># --- Check if file already exists; if so, skip export ---</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping export: File already exists at </span><span class="si">{</span><span class="n">output_filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">continue</span> <span class="c1"># Skip to the next iteration of the loop for the next dataset</span>
    
    <span class="c1"># Create a new NetCDF file in write mode (&quot;w&quot;).</span>
    <span class="c1"># `nc.Dataset` is used for creating and writing to NetCDF files.</span>
    <span class="k">with</span> <span class="n">nc</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">output_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;NETCDF4_CLASSIC&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output_dataset</span><span class="p">:</span>
        <span class="c1"># --- Copy Global Attributes ---</span>
        <span class="c1"># Iterate through all global attributes of the input dataset.</span>
        <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">():</span>
            <span class="c1"># Exclude &quot;VAR_LIST&quot; from direct copying as it will be reconstructed.</span>
            <span class="k">if</span> <span class="n">attr_name</span> <span class="o">!=</span> <span class="s2">&quot;VAR_LIST&quot;</span><span class="p">:</span>
                <span class="n">output_dataset</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">))</span>
        
        <span class="c1"># Reconstruct and set the &quot;VAR_LIST&quot; attribute for the output file.</span>
        <span class="c1"># This attribute lists the variables contained within the new file, formatted as &#39;;var1;var2;&#39;.</span>
        <span class="n">var_list_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="n">test_variable</span><span class="p">]])</span> <span class="o">+</span> <span class="s2">&quot;;&quot;</span> <span class="c1"># Only `test_variable` is exported.</span>
        <span class="n">output_dataset</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="s1">&#39;VAR_LIST&#39;</span><span class="p">,</span> <span class="n">var_list_str</span><span class="p">)</span>
        
        <span class="c1"># --- Create Dimensions ---</span>
        <span class="c1"># Get dimensions from the *first* variable (or general structure) of the input dataset.</span>
        <span class="c1"># Assuming `variable_data` is (time, (z_level), y, x)</span>
        
        <span class="c1"># `num_time`: number of aggregated time steps.</span>
        <span class="c1"># `num_z_level`: fixed to 1 as we&#39;re exporting a single 2D layer (e.g., z=0).</span>
        <span class="c1"># `num_y`: number of rows in the 2D array.</span>
        <span class="c1"># `num_x`: number of columns in the 2D array.</span>
        <span class="n">num_time</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variable_data_agg</span><span class="p">)</span>
        <span class="n">num_z_level</span> <span class="o">=</span> <span class="mi">1</span> 
        <span class="n">num_y</span> <span class="o">=</span> <span class="n">variable_data_agg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Number of rows (y-dimension)</span>
        <span class="n">num_x</span> <span class="o">=</span> <span class="n">variable_data_agg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Number of columns (x-dimension)</span>
        
        <span class="n">output_dataset</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">num_time</span><span class="p">)</span>
        <span class="n">output_dataset</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">num_z_level</span><span class="p">)</span> <span class="c1"># Creating a z-dimension with size 1 for consistency.</span>
        <span class="n">output_dataset</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">num_y</span><span class="p">)</span> 
        <span class="n">output_dataset</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">num_x</span><span class="p">)</span> 
        
        <span class="c1"># Also copy coordinate variables if they exist and are useful</span>
        <span class="k">if</span> <span class="s1">&#39;time&#39;</span> <span class="ow">in</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">time_var</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,))</span>
            <span class="n">time_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">][</span><span class="n">time_lists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">time_lists</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">aggregate_time_steps</span><span class="p">]</span> <span class="c1"># Simplified time assignment.</span>
            <span class="c1"># This assumes time steps are regular. A more precise way would be to average time, or pick central time.</span>
            <span class="c1"># For this context, picking the start of the first window to the end of the last window at aggregation interval.</span>
        <span class="k">if</span> <span class="s1">&#39;z&#39;</span> <span class="ow">in</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">z_var</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,))</span>
            <span class="n">z_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Copy the z-coordinate of the extracted layer.</span>
        <span class="k">if</span> <span class="s1">&#39;y&#39;</span> <span class="ow">in</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">y_var</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,))</span>
            <span class="n">y_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">][:]</span>
        <span class="k">if</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">current_dataset</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="n">x_var</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,))</span>
            <span class="n">x_var</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">current_dataset</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">][:]</span>


        <span class="c1"># Create the variable in the new NetCDF file.</span>
        <span class="c1"># The dimensions are (time, z, y, x) to maintain a consistent structure with PALM 4D outputs.</span>
        <span class="n">data_var</span> <span class="o">=</span> <span class="n">output_dataset</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">test_variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">),</span> 
                                               <span class="n">fill_value</span><span class="o">=</span><span class="n">variable_data</span><span class="o">.</span><span class="n">_FillValue</span> <span class="k">if</span> <span class="s1">&#39;_FillValue&#39;</span> <span class="ow">in</span> <span class="n">variable_data</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()</span> <span class="k">else</span> <span class="o">-</span><span class="mf">9999.0</span><span class="p">)</span> <span class="c1"># Copy fill value</span>

        <span class="c1"># Fill the newly created variable with the aggregated 2D data.</span>
        <span class="c1"># Each aggregated 2D array is assigned to its corresponding time step and the first z-layer.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">variable_data_agg</span><span class="p">):</span>
            <span class="n">data_var</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">array</span> <span class="c1"># Assign the 2D aggregated array to the NetCDF variable</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Successfully extracted and saved aggregated data for &#39;</span><span class="si">{</span><span class="n">test_variable</span><span class="si">}</span><span class="s2">&#39; to: </span><span class="si">{</span><span class="n">output_filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Skipping export: File already exists at ./output/04_aggregated_2D_data/konstanz_4096x4096_v9_Baseline_av_xy_N03_ta_2m_xy.nc
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Skipping export: File already exists at ./output/04_aggregated_2D_data/konstanz_4096x4096_v9_Scenario_1_av_xy_N03_ta_2m_xy.nc
</pre></div>
</div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="04_Air_Temp_Analysis_Heatmaps.html" class="btn btn-neutral float-left" title="2D Air Temperature Analysis: Heatmaps" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="06_Bio_Var_Analysis_BS_vs_S1.html" class="btn btn-neutral float-right" title="2D Biometeorological Variable Analysis: Baseline vs. Scenario" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, str.ucture GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>